% Chapter 3 - Metodologi Penelitian
\chapter{METODE PENELITIAN}
\label{chap:metodologi}

\section{Bahan dan Data}
Bahan dan data yang digunakan dalam penelitian ini meliputi:

\begin{enumerate}
    \item \textbf{Objek Penelitian}: Kode sumber proyek \textbf{Paicode}, sebuah agen AI berbasis CLI yang dikembangkan sebagai studi kasus utama.
    \item \textbf{Dokumentasi Teknis}: Dokumentasi resmi pustaka Google Generative AI (Gemini API), pustaka \texttt{rich} untuk antarmuka terminal, dan standar keamanan sistem operasi Linux.
    \item \textbf{Literatur}: Referensi ilmiah berupa jurnal, prosiding, dan artikel terkait \textit{agentic AI}, \textit{Large Language Model} (LLM), dan rekayasa perangkat lunak yang digunakan sebagai landasan teori dan perbandingan.
    \item \textbf{Data Uji}: Skenario pengujian yang mencakup pembuatan struktur proyek, manipulasi berkas, dan refaktorisasi kode untuk mengukur kinerja agen.
\end{enumerate}

\section{Peralatan}
Peralatan yang digunakan untuk mendukung penelitian ini terdiri dari perangkat keras dan perangkat lunak dengan spesifikasi sebagai berikut:

\begin{itemize}
  \item \textbf{Perangkat Keras}:
  \begin{itemize}
    \item Komputer/Laptop dengan prosesor arsitektur x86\_64.
    \item Memori (RAM) minimal 8 GB untuk menjalankan lingkungan pengembangan dengan lancar.
    \item Koneksi internet stabil untuk akses ke API Gemini.
  \end{itemize}

  \item \textbf{Perangkat Lunak}:
  \begin{itemize}
    \item \textbf{Sistem Operasi}: Ubuntu (Linux) sebagai lingkungan pengembangan dan target implementasi utama.
    \item \textbf{Bahasa Pemrograman}: Python (\texttt{\textgreater= 3.10}) sebagai bahasa implementasi utama.
    \item \textbf{Manajer Dependensi}: \texttt{pip} dan \texttt{venv} untuk isolasi lingkungan; \texttt{Makefile} untuk otomasi tugas.
    \item \textbf{Layanan LLM}: Google Gemini via \texttt{google-generativeai} (versi $\geq$ 0.5.4) sebagai otak agen.
    \item \textbf{Antarmuka Terminal (TUI)}: Pustaka \texttt{rich} (versi $\geq$ 13.7.1) untuk visualisasi output dan \texttt{prompt\_toolkit} (opsional) untuk interaksi input.
    \item \textbf{Penyunting Kode}: VS Code atau editor teks berbasis terminal (Vim/Nano) untuk penulisan kode sumber.
    \item \textbf{Penyusun Laporan}: \LaTeX{} (TeX Live) untuk penyusunan dokumen skripsi.
    \item \textbf{Kendali Versi}: Git dan GitHub untuk manajemen kode sumber.
  \end{itemize}
\end{itemize}

\section{Prosedur dan Pengumpulan Data}
Penelitian ini menggunakan pendekatan \textit{Research and Development} (R\&D) dengan strategi \textit{prototyping} iteratif. Tahapan prosedur penelitian dan pengumpulan data dilakukan sebagai berikut:

\begin{enumerate}
  \item \textbf{Identifikasi Masalah}: Menganalisis keterbatasan alat bantu pemrograman saat ini (ketergantungan pada IDE, masalah privasi cloud, biaya token tinggi) dan merumuskan kebutuhan akan agen CLI lokal yang efisien.
  
  \item \textbf{Studi Literatur}: Mengumpulkan referensi tentang \textit{agentic AI}, arsitektur \textit{Single-Shot Intelligence}, dan keamanan sistem file lokal.
  
  \item \textbf{Perancangan Sistem}: Merancang arsitektur Paicode, mendefinisikan himpunan perintah (\texttt{READ}, \texttt{WRITE}, dll.), dan merancang kebijakan keamanan \textit{path security}.
  
  \item \textbf{Implementasi Prototipe}: Membangun modul-modul inti secara iteratif:
  \begin{itemize}
      \item Iterasi 1: Antarmuka CLI dasar dan integrasi LLM.
      \item Iterasi 2: Implementasi \textit{Workspace Controller} dan \textit{Path Security}.
      \item Iterasi 3: Implementasi arsitektur \textit{Single-Shot Intelligence} dan mekanisme \textit{diff}-aware.
  \end{itemize}
  
  \item \textbf{Pengujian dan Evaluasi}:
  \begin{itemize}
      \item Menjalankan skenario tugas pemrograman representatif (pembuatan proyek, modifikasi fitur).
      \item Mengumpulkan data metrik efisiensi (waktu eksekusi, jumlah panggilan API) dan kualitas (keberhasilan kompilasi).
      \item Mengevaluasi keamanan dengan mencoba skenario akses ilegal ke direktori sensitif.
  \end{itemize}
  
  \item \textbf{Analisis dan Pelaporan}: Menganalisis data hasil pengujian untuk menarik kesimpulan mengenai efektivitas arsitektur yang diusulkan dan menyusun laporan akhir.
\end{enumerate}

Pemilihan metode \textit{prototyping} memungkinkan validasi cepat terhadap asumsi desain, khususnya dalam hal manajemen state agen dan efektivitas kebijakan keamanan, serta memungkinkan perbaikan berkelanjutan berdasarkan temuan empiris selama fase pengembangan.

\section{Analisis dan Rancangan Sistem}
Bagian ini menguraikan analisis kebutuhan dan rancangan arsitektur sistem Paicode yang dibangun.

\subsection{Analisis Sistem}

Sistem dirancang untuk memenuhi kebutuhan fungsional dan non-fungsional sebagai berikut:

\textbf{Kebutuhan Fungsional}:
\begin{itemize}
    \item Sistem harus dapat menerima instruksi bahasa alami dari pengguna melalui terminal.
    \item Sistem harus mampu melakukan operasi berkas (baca, tulis, daftar, hapus) di dalam direktori kerja proyek.
    \item Sistem harus mampu memodifikasi konten berkas kode secara spesifik tanpa menimpa seluruh berkas yang tidak relevan.
    \item Sistem harus memiliki mekanisme perencanaan (\textit{planning}) sebelum mengeksekusi tindakan berisiko.
\end{itemize}

\textbf{Kebutuhan Non-Fungsional}:
\begin{itemize}
    \item \textbf{Keamanan}: Sistem wajib memblokir akses ke direktori sensitif (\texttt{.git}, \texttt{.env}) dan mencegah "halusinasi" yang merusak direktori di luar proyek.
    \item \textbf{Efisiensi}: Sistem harus meminimalkan jumlah panggilan API dan penggunaan token untuk mengurangi biaya dan latensi.
    \item \textbf{Transparansi}: Sistem harus memberikan umpan balik visual yang jelas mengenai tindakan yang sedang dan telah dilakukan.
\end{itemize}

\subsection{Rancangan Arsitektur}
Arsitektur Paicode dirancang secara modular dengan komponen-komponen utama sebagai berikut:

\begin{itemize}
  \item \textbf{Antarmuka CLI (\texttt{cli.py})}: Menangani input pengguna, argumen baris perintah, dan inisialisasi sesi.
  \item \textbf{Agen Cerdas (\texttt{agent.py})}: Mengimplementasikan logika \textit{Single-Shot Intelligence}, mencakup klasifikasi intensi, perencanaan JSON, dan orkestrasi eksekusi adaptif (1-3 subfase). Modul ini juga mengelola memori percakapan jangka pendek.
  \item \textbf{Jembatan LLM (\texttt{llm.py})}: Mengelola komunikasi dengan API Gemini, termasuk manajemen API key tunggal dan sanitasi output.
  \item \textbf{Pengatur Workspace (\texttt{workspace.py})}: Bertindak sebagai penjaga gerbang (\textit{gatekeeper}) untuk semua operasi sistem file. Modul ini menegakkan \textit{path security policy} (whitelist/blacklist path) dan mengelola mekanisme modifikasi berbasis \textit{diff} dengan threshold aman.
  \item \textbf{Manajemen Konfigurasi (\texttt{config.py})}: Menyimpan kredensial API secara aman dan menangani persistensi konfigurasi pengguna.
  \item \textbf{Tampilan UI (\texttt{ui.py})}: Mengelola rendering output yang kaya (\textit{rich text}) untuk pengalaman pengguna yang lebih baik di terminal.
\end{itemize}

\subsection{Visualisasi Interaksi Modul}

Berikut adalah diagram ketergantungan antar modul dalam sistem:

% Tabel 3.1: Diagram modul dan dependensi
\begin{longtable}{@{}p{0.25\textwidth}p{0.70\textwidth}@{}}
  \caption{Relasi Modul dan Tanggung Jawab}\label{tab:diagram-modul}\\
  \toprule
  \textbf{Modul} & \textbf{Tanggung Jawab Utama} \\
  \midrule
  \endfirsthead
  \toprule
  \textbf{Modul} & \textbf{Tanggung Jawab Utama} \\
  \midrule
  \endhead
  \texttt{cli.py} & Entry point, parsing argumen. \\
  \texttt{agent.py} & Logika bisnis utama, perencanaan (\textit{planning}), eksekusi (\textit{execution loop}). \\
  \texttt{llm.py} & Abstraksi API Gemini, manajemen token. \\
  \texttt{workspace.py} & Operasi I/O berkas, validasi keamanan path, penerapan \textit{diff}. \\
  \texttt{config.py} & Penyimpanan dan validasi API Key. \\
  \texttt{ui.py} & Rendering output, spinner status, syntax highlighting. \\
  \bottomrule
\end{longtable}

Diagram alur interaksi umum dalam satu sesi (\textit{turn}) adalah sebagai berikut:

% Tabel 3.2: Urutan interaksi (sequence) sesi agen
\begin{longtable}{@{}p{0.10\textwidth}p{0.25\textwidth}p{0.60\textwidth}@{}}
  \caption{Alur Eksekusi Perintah dalam Arsitektur Single-Shot}\label{tab:sequence-session}\\
  \toprule
  \textbf{Langkah} & \textbf{Komponen} & \textbf{Aksi} \\
  \midrule
  \endfirsthead
  \toprule
  \textbf{Langkah} & \textbf{Komponen} & \textbf{Aksi} \\
  \midrule
  \endhead
  1 & User/CLI & Pengguna memasukkan instruksi tugas. \\
  2 & Agen & Mengirim konteks + instruksi ke LLM untuk perencanaan. \\
  3 & LLM & Mengembalikan rencana eksekusi dalam format JSON. \\
  4 & Agen & Memvalidasi rencana dan menampilkan ke pengguna. \\
  5 & Agen & Mengeksekusi langkah-langkah rencana (loop subfase). \\
  6 & Workspace & Menjalankan operasi fisik (baca/tulis) dengan validasi keamanan. \\
  7 & Agen & Menyimpan hasil ke riwayat percakapan. \\
  \bottomrule
\end{longtable}
