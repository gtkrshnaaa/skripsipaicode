% Chapter 3 - Metodologi Penelitian
\chapter{METODE PENELITIAN}
\label{chap:metodologi}

\section{Bahan Penelitian}
\indent Bahan yang digunakan dalam penelitian ini meliputi:

\begin{enumerate}
    \item \textbf{Kode Sumber Paicode}: Kode sumber proyek \textbf{Paicode}, sebuah agen AI berbasis CLI yang dikembangkan sebagai studi kasus utama.
    \item \textbf{Dokumentasi Teknis}: Dokumentasi resmi pustaka Google Generative AI (Gemini API), pustaka \texttt{rich} untuk antarmuka terminal, dan standar keamanan sistem operasi Linux.
    \item \textbf{Skenario Pengujian}: Skenario pengujian yang mencakup pembuatan struktur proyek, manipulasi berkas, dan refaktorisasi kode untuk mengukur kinerja agen.
\end{enumerate}

\section{Peralatan}
\indent Peralatan yang digunakan untuk mendukung penelitian ini terdiri dari perangkat keras dan perangkat lunak dengan spesifikasi sebagai berikut:

\begin{enumerate}
  \item \textbf{Perangkat Keras}:
  \begin{enumerate}
    \item Komputer/Laptop dengan prosesor arsitektur x86\_64.
    \item Memori (RAM) minimal 8 GB untuk menjalankan lingkungan pengembangan dengan lancar.
    \item Koneksi internet stabil untuk akses ke API Gemini.
  \end{enumerate}

  \item \textbf{Perangkat Lunak}:
  \begin{enumerate}
    \item \textbf{Sistem Operasi}: Ubuntu (Linux) sebagai lingkungan pengembangan dan target implementasi utama.
    \item \textbf{Bahasa Pemrograman}: Python (\texttt{\textgreater= 3.10}) sebagai bahasa implementasi utama.
    \item \textbf{Manajer Dependensi}: \texttt{pip} dan \texttt{venv} untuk isolasi lingkungan; \texttt{Makefile} untuk otomasi tugas.
    \item \textbf{Layanan LLM}: Google Gemini via \texttt{google-generativeai} (versi $\geq$ 0.5.4) sebagai otak agen.
    \item \textbf{Antarmuka Terminal (TUI)}: Pustaka \texttt{rich} (versi $\geq$ 13.7.1) untuk visualisasi output dan \texttt{prompt\_toolkit} (opsional) untuk interaksi input.
    \item \textbf{Penyunting Kode}: VS Code atau editor teks berbasis terminal (Vim/Nano) untuk penulisan kode sumber.
    \item \textbf{Penyusun Laporan}: \LaTeX{} (TeX Live) untuk penyusunan dokumen skripsi, memanfaatkan paket \texttt{TikZ} untuk pembuatan diagram dan flowchart, \texttt{listings} untuk penulisan kode program, serta \texttt{longtable} untuk penyajian tabel yang kompleks.
    \item \textbf{Kendali Versi}: Git dan GitHub untuk manajemen kode sumber.
  \end{enumerate}
\end{enumerate}

\section{Metodologi Penelitian}
\indent Penelitian ini menggunakan pendekatan \textit{Research and Development} (R\&D) dengan strategi \textit{prototyping} iteratif. Pendekatan ini dipilih karena memungkinkan pengembangan dan evaluasi sistem secara bertahap, dengan siklus pengembangan yang dapat disesuaikan berdasarkan hasil pengujian di setiap iterasi.

\subsection{Tahapan Penelitian}
\indent Tahapan penelitian dilakukan secara berurutan sebagai berikut:

\begin{enumerate}
  \item \textbf{Identifikasi Masalah}: Menganalisis keterbatasan alat bantu pemrograman berbasis AI saat ini, termasuk ketergantungan pada IDE, masalah privasi pada solusi cloud-based, dan biaya token yang tinggi pada arsitektur chat-loop tradisional.
  
  \item \textbf{Studi Literatur}: Mempelajari konsep \textit{agentic AI}, arsitektur \textit{Single-Shot Intelligence}, mekanisme tool-use pada LLM, dan praktik terbaik dalam keamanan sistem file pada lingkungan CLI.
  
  \item \textbf{Analisis Kebutuhan}: Mendefinisikan kebutuhan fungsional dan non-fungsional sistem berdasarkan identifikasi masalah dan studi literatur.
  
  \item \textbf{Perancangan Sistem}: Merancang arsitektur modular, mendefinisikan komponen-komponen utama, alur kerja sistem, dan kebijakan keamanan \textit{path security}.
  
  \item \textbf{Implementasi Prototipe}: Membangun sistem secara iteratif dengan pendekatan \textit{incremental development}:
  \begin{enumerate}
      \item Iterasi 1: Antarmuka CLI dasar dan integrasi dengan API Gemini.
      \item Iterasi 2: Implementasi \textit{Workspace Controller} dan mekanisme \textit{path security}.
      \item Iterasi 3: Implementasi arsitektur \textit{Single-Shot Intelligence} dan sistem modifikasi berbasis \textit{diff}.
  \end{enumerate}
  
  \item \textbf{Pengujian Fungsional}: Menjalankan skenario pengujian untuk memvalidasi fungsionalitas sistem, termasuk pembuatan proyek, modifikasi kode, dan refaktorisasi.
  
  \item \textbf{Evaluasi Keamanan}: Menguji efektivitas kebijakan \textit{path security} dengan mencoba skenario akses ke direktori sensitif dan path traversal.
  
  \item \textbf{Analisis Hasil}: Menganalisis hasil pengujian untuk mengevaluasi efektivitas arsitektur yang diusulkan dan mengidentifikasi area perbaikan.
  
  \item \textbf{Dokumentasi}: Menyusun dokumentasi teknis dan laporan penelitian.
\end{enumerate}

Pemilihan metode \textit{prototyping} iteratif memungkinkan validasi cepat terhadap asumsi desain, khususnya dalam hal efektivitas arsitektur \textit{Single-Shot Intelligence} dan kebijakan keamanan, serta memungkinkan perbaikan berkelanjutan berdasarkan temuan empiris pada setiap iterasi.

\section{Analisis Kebutuhan Sistem}
\indent Berdasarkan identifikasi masalah dan studi literatur, sistem dirancang untuk memenuhi kebutuhan sebagai berikut:

\subsection{Kebutuhan Fungsional}
\begin{enumerate}
    \item Sistem harus dapat menerima instruksi dalam bahasa alami dari pengguna melalui antarmuka CLI.
    \item Sistem harus mampu melakukan operasi berkas (membaca, menulis, membuat, menghapus) di dalam direktori kerja proyek.
    \item Sistem harus mampu memodifikasi konten berkas kode secara spesifik menggunakan mekanisme \textit{diff}-based editing tanpa menimpa seluruh berkas.
    \item Sistem harus memiliki fase perencanaan (\textit{planning phase}) sebelum mengeksekusi tindakan yang berisiko mengubah berkas.
\end{enumerate}

\subsection{Kebutuhan Non-Fungsional}
\begin{enumerate}
    \item \textbf{Keamanan}: Sistem wajib memblokir akses ke direktori sensitif (\texttt{.git}, \texttt{.env}, \texttt{node\_modules}) dan mencegah operasi pada path di luar direktori proyek untuk menghindari kerusakan sistem.
    \item \textbf{Efisiensi}: Sistem harus meminimalkan jumlah panggilan API melalui arsitektur \textit{Single-Shot Intelligence} untuk mengurangi biaya operasional dan latensi respons.
    \item \textbf{Transparansi}: Sistem harus memberikan visualisasi yang jelas mengenai rencana tindakan dan status eksekusi melalui antarmuka terminal yang terstruktur.
\end{enumerate}

\section{Perancangan Sistem}
\indent Bagian ini menjelaskan arsitektur sistem, komponen-komponen utama, dan alur kerja sistem Paicode.

\subsection{Arsitektur Modular}
\indent Arsitektur Paicode dirancang secara modular dengan pemisahan tanggung jawab yang jelas antar komponen. Arsitektur modular ini memudahkan pengembangan, pengujian, dan pemeliharaan sistem. Komponen-komponen utama sistem adalah:

\begin{enumerate}
  \item \textbf{Antarmuka CLI (\texttt{cli.py})}: Menangani input pengguna, parsing argumen baris perintah, dan inisialisasi sesi interaktif.
  
  \item \textbf{Agen Cerdas (\texttt{agent.py})}: Mengimplementasikan logika \textit{Single-Shot Intelligence}, mencakup klasifikasi intensi (membedakan percakapan biasa dan tugas pemrograman), fase perencanaan JSON terstruktur, dan orkestrasi eksekusi adaptif yang dapat berjalan dalam 1-3 subfase tergantung kompleksitas tugas. Modul ini juga mengelola memori percakapan jangka pendek.
  
  \item \textbf{Jembatan LLM (\texttt{llm.py})}: Mengelola komunikasi dengan API Gemini, termasuk manajemen API key dan sanitasi output untuk memastikan response dalam format yang konsisten.
  
  \item \textbf{Pengatur Workspace (\texttt{workspace.py})}: Bertindak sebagai \textit{gatekeeper} untuk semua operasi sistem file. Modul ini menegakkan \textit{path security policy} (whitelist/blacklist direktori) dan mengelola mekanisme modifikasi berbasis \textit{diff} dengan threshold keamanan (maksimal 500 baris atau 50\% dari total baris berkas).
  
  \item \textbf{Manajemen Konfigurasi (\texttt{config.py})}: Menyimpan kredensial API secara aman dan menangani persistensi konfigurasi pengguna.
  
  \item \textbf{Tampilan UI (\texttt{ui.py})}: Mengelola rendering output terminal menggunakan pustaka \texttt{rich}, termasuk syntax highlighting, tabel terstruktur, dan spinner status untuk meningkatkan pengalaman pengguna.
\end{enumerate}

\subsection{Deskripsi Modul}
\indent Tabel berikut merangkum tanggung jawab utama dari setiap modul dalam sistem:

\begin{longtable}{|p{0.28\textwidth}|>{\hyphenpenalty=50\tolerance=1000}p{0.677\textwidth}|}
  \caption{Daftar Modul dan Tanggung Jawab Utama}\label{tab:diagram-modul}\\
  \hline
  \textbf{Modul} & \textbf{Tanggung Jawab Utama} \\
  \hline
  \endfirsthead
  \hline
  \textbf{Modul} & \textbf{Tanggung Jawab Utama} \\
  \hline
  \endhead
  \texttt{cli.py} & Entry point aplikasi, parsing argumen CLI, inisialisasi sesi. \\ \hline
  \texttt{agent.py} & Logika bisnis utama, klasifikasi intensi, perencanaan terstruktur (JSON), orkestrasi eksekusi adaptif, manajemen memori percakapan. \\ \hline
  \texttt{llm.py} & Abstraksi komunikasi dengan API Gemini, manajemen token, sanitasi response. \\ \hline
  \texttt{workspace.py} & Operasi I/O berkas, penegakan kebijakan \textit{path security}, penerapan modifikasi berbasis \textit{diff} dengan threshold keamanan. \\ \hline
  \texttt{config.py} & Penyimpanan aman dan validasi API Key, manajemen konfigurasi pengguna. \\ \hline
  \texttt{ui.py} & Rendering output terminal dengan \texttt{rich}, syntax highlighting, visualisasi status. \\ \hline
\end{longtable}

\subsection{Alur Kerja Sistem}
\indent Alur kerja sistem dalam satu sesi interaksi pengguna (satu \textit{turn}) ditunjukkan pada Gambar~\ref{fig:flowchart-sistem}.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[node distance=1.5cm, auto,
    startstop/.style={rectangle, rounded corners, minimum width=3cm, minimum height=1cm, text centered, draw=black},
    process/.style={rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black},
    io/.style={trapezium, trapezium left angle=70, trapezium right angle=110, minimum width=3cm, minimum height=1cm, text centered, draw=black},
    decision/.style={diamond, minimum width=3cm, minimum height=1cm, text centered, draw=black},
    arrow/.style={thick,->,>=stealth}
  ]

    \node (start) [startstop] {Mulai};
    \node (input) [io, below of=start] {Input Instruksi User};
    \node (llm_plan) [process, below of=input] {LLM: Buat Rencana (JSON)};
    \node (validate) [decision, below of=llm_plan, yshift=-1.5cm] {Validasi Rencana?};
    \node (execute) [process, below of=validate, yshift=-1.5cm] {Eksekusi Langkah (Loop)};
    \node (workspace) [process, below of=execute] {Operasi Workspace (I/O)};
    \node (finish) [startstop, below of=workspace] {Selesai / Simpan History};

    \draw[arrow] (start) -- (input);
    \draw[arrow] (input) -- (llm_plan);
    \draw[arrow] (llm_plan) -- (validate);
    \draw[arrow] (validate.east) -- node[anchor=south] {Tolak} +(1,0) |- (input.east);
    \draw[arrow] (validate) -- node[anchor=east] {Setuju} (execute);
    \draw[arrow] (execute) -- (workspace);
    \draw[arrow] (workspace) -- (finish);

  \end{tikzpicture}
  \caption{Flowchart alur eksekusi perintah dalam arsitektur \textit{Single-Shot Intelligence}.}
  \label{fig:flowchart-sistem}
\end{figure}

\nopagebreak[4]
\indent Alur kerja dimulai dengan penerimaan instruksi pengguna, kemudian LLM membuat rencana tindakan dalam format JSON terstruktur. Rencana ini divalidasi oleh sistem (termasuk pengecekan \textit{path security}). Jika valid, sistem mengeksekusi langkah-langkah dalam rencana secara berurutan dengan melakukan operasi pada workspace melalui modul \texttt{workspace.py}. Hasil eksekusi disimpan ke riwayat percakapan untuk menjaga konteks.
