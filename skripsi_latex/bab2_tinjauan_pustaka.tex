% Chapter 2 - Tinjauan Pustaka
\chapter{Tinjauan Pustaka}
\label{chap:tinjauan}

\section{Teori Dasar}
Bagian ini membahas konsep yang menjadi landasan penelitian: \textit{Command Line Interface} (CLI), agen kecerdasan buatan (AI Agent), \textit{Large Language Model} (LLM), arsitektur dan kebijakan data (integrasi LLM melalui API dan implikasi privasi), \textit{Single-Shot Intelligence} untuk agen interaktif, sistem klasifikasi intensi, serta perangkat bantu yang digunakan seperti pip dan virtual environment untuk manajemen dependensi, \texttt{rich} dan \texttt{prompt\_toolkit} untuk antarmuka terminal.

\subsection{Command Line Interface (CLI)}
CLI adalah antarmuka berbasis teks yang memungkinkan pengguna berinteraksi dengan sistem melalui perintah. Kelebihan CLI meliputi otomasi yang mudah, konsumsi sumber daya yang rendah, dan integrasi sederhana dengan alat lain melalui skrip. Dalam konteks pengembangan perangkat lunak, CLI memfasilitasi alur kerja yang ringkas dan dapat direproduksi.

\subsection{AI Agent}
AI Agent (sering disebut \textit{agentic AI} dalam literatur; selanjutnya disingkat "agen AI") dalam penelitian ini dipahami sebagai sistem yang mampu mengobservasi lingkungan (struktur proyek dan isi berkas), merencanakan tindakan (mis. membuat, membaca, memodifikasi berkas), serta mengevaluasi hasil untuk langkah berikutnya. Agen bersifat \textit{stateful} karena mempertahankan konteks percakapan dan hasil eksekusi sebagai memori kerja, sehingga dapat bertindak secara lebih \textit{proactive}.

Pada implementasi Paicode, agen menggunakan arsitektur \textit{Single-Shot Intelligence} yang terdiri dari beberapa komponen: (1) klasifikasi intensi untuk membedakan percakapan dan tugas, (2) \textit{acknowledgment} dinamis untuk konfirmasi pemahaman, (3) fase perencanaan dengan analisis mendalam dan perencanaan komprehensif dalam format JSON, (4) fase eksekusi adaptif yang dapat berjalan dalam 1-3 subfase berdasarkan kompleksitas tugas, dan (5) saran langkah berikutnya. Sistem ini mengoptimalkan efisiensi dibandingkan pendekatan tradisional yang memerlukan banyak panggilan API berulang.

\subsection{Large Language Model (LLM)}
LLM merupakan model generatif berskala besar yang mampu memahami instruksi dan menghasilkan teks atau kode. Pada penelitian ini digunakan API Gemini sebagai penyedia LLM untuk menghasilkan konten baru (\texttt{WRITE}) dan menerapkan perubahan terarah (\texttt{MODIFY}) berdasarkan deskripsi. Prinsip kehati-hatian diterapkan dengan mekanisme pembatasan perubahan berbasis \textit{diff} sehingga modifikasi tidak berskala besar tanpa kontrol \cite{brown2020gpt3,openai2023gpt4,gemini2023,touvron2023llama,llama2_2023,schick2023toolformer,yao2023react}.

\subsection{Perbedaan LLM dan Agen AI}
\label{subsec:llm-vs-agent}
Pada skripsi ini penting untuk membedakan \textit{Large Language Model} (LLM) dan \textit{Agen AI}:
\begin{itemize}
  \item \textbf{LLM}: model generatif yang menghasilkan keluaran berbasis teks/kode dari masukan. LLM \emph{tidak} menjalankan aksi pada berkas secara langsung; ia hanya memberikan saran/hasil teks.
  \item \textbf{Agen AI}: komponen perangkat lunak yang \emph{mengatur alur kerja} (melakukan perencanaan, memanggil LLM, dan mengeksekusi aksi nyata). Pada konteks ini, agen mengontrol perintah CLI untuk melakukan \textbf{operasi berkas tingkat-aplikasi pada workspace proyek}.
  \item \textbf{Hubungan}: agen memanfaatkan LLM untuk penalaran/generasi, lalu menerjemahkan hasilnya menjadi aksi yang terkontrol. Pengamanan lokal ditegakkan melalui \textit{path security} (keamanan \textit{path}) dan pembatasan perubahan berbasis \textit{diff}.
\end{itemize}

\subsection{Arsitektur dan Kebijakan Data}
Paicode dijalankan pada terminal lokal dan melakukan tindakan langsung pada \textbf{berkas proyek di workspace}. Akan tetapi, untuk kebutuhan inferensi, cuplikan kode atau konteks \textbf{dikirim ke layanan LLM melalui API}. Implikasinya, privasi dan kerahasiaan kode \textbf{bergantung pada kebijakan penyedia API}. Pengamanan di sisi lokal diterapkan melalui kebijakan \textit{path security} (keamanan \textit{path}) serta pembatasan perubahan berbasis \textit{diff} agar operasi berkas lebih terkendali.

\subsection{Manajemen Dependensi dengan pip dan Virtual Environment}
Paicode menggunakan pendekatan manajemen dependensi tradisional dengan pip dan virtual environment Python. Berkas \texttt{requirements.txt} mendeskripsikan dependensi yang diperlukan, sementara Makefile menyediakan otomasi untuk pembuatan virtual environment dan instalasi dependensi. Pendekatan ini memudahkan replikasi lingkungan dan instalasi alat. Pada implementasi Paicode, dependensi utama meliputi \texttt{google-generativeai} (versi $\geq$ 0.5.4), \texttt{rich} (versi $\geq$ 13.7.1), \texttt{Pygments} (versi $\geq$ 2.16.0), dan \texttt{prompt\_toolkit} (versi $\geq$ 3.0.43).

\subsection{Antarmuka Terminal dengan \texttt{rich} dan \texttt{prompt\_toolkit}}
Paket \texttt{rich} dimanfaatkan untuk menyajikan hasil eksekusi secara terstruktur dan mudah dibaca (panel, warna, penyorotan sintaks, tabel, dan spinner status). Penyajian output yang jelas mendukung pengalaman interaktif dan penelusuran hasil tindakan agen. Selain itu, Paicode juga mengintegrasikan \texttt{prompt\_toolkit} (opsional) untuk pengalaman input yang lebih baik dengan dukungan multiline editing dan key bindings. Jika \texttt{prompt\_toolkit} tidak tersedia, sistem akan fallback ke \texttt{rich.prompt.Prompt}.

\section{Penelitian Terkait}
Berbagai alat bantu pengembangan perangkat lunak berbasis LLM telah diusulkan dan dikomersialisasi, antara lain asisten kode terintegrasi editor, agen otomatis untuk \textit{refactoring}, serta sistem tanya-jawab dokumentasi. Umumnya solusi tersebut beroperasi sebagai ekstensi editor atau layanan daring, sehingga kuat pada integrasi IDE namun bergantung pada antarmuka tertentu dan memproses konteks di luar mesin pengguna.

Sebaliknya, Paicode menempatkan agen di lingkungan CLI dan beroperasi langsung pada \textbf{berkas proyek di workspace}, sementara inferensi dilakukan oleh LLM eksternal melalui API. Perintah agen disederhanakan ke dalam himpunan tindakan yang eksplisit (\texttt{MKDIR}, \texttt{TOUCH}, \texttt{READ}, \texttt{WRITE}, \texttt{MODIFY}, \texttt{RM}, \texttt{MV}, \texttt{TREE}, \texttt{LIST\_PATH}, \texttt{FINISH}) dengan \textit{policy} \textit{path security}. Penelitian terkait menunjukkan bahwa interaksi \textit{stateful} berbasis rencana aksi meningkatkan kualitas hasil pada tugas-tugas rekayasa perangkat lunak yang iteratif, sementara \textit{guardrail} sederhana (seperti pembatasan \textit{diff}) dapat menekan risiko penimpaan berkas secara tidak disengaja.

\section{Posisi Penelitian}
Kontribusi penelitian ini ditempatkan pada ranah agentic AI untuk pengembangan perangkat lunak dengan karakteristik sebagai berikut:

\begin{itemize}
  \item \textbf{CLI lokal dengan integrasi LLM via API}: agen berjalan di terminal, tindakan langsung tercermin pada \textbf{berkas proyek di workspace}; sementara inferensi dilakukan oleh LLM eksternal sehingga kebijakan data mengikuti penyedia API.
  \item \textbf{Arsitektur Single-Shot Intelligence}: alur kerja efisien yang mengoptimalkan penggunaan API dengan tepat 2 panggilan (perencanaan dan eksekusi), menggantikan pendekatan tradisional yang memerlukan 10-20 panggilan API.
  \item \textbf{Manajemen API key tunggal}: sistem manajemen API key yang disederhanakan dengan migrasi otomatis dari sistem multi-key untuk kemudahan penggunaan.
  \item \textbf{Keamanan berkas}: kebijakan pelarangan akses \textit{path} sensitif dan validasi \textit{path} mencegah \textit{path traversal} dan operasi berisiko pada direktori seperti \texttt{.git}, \texttt{venv}, dan \texttt{.env}.
  \item \textbf{Modifikasi terarah berbasis diff}: perintah \texttt{MODIFY} memanfaatkan sistem \textit{diff}-aware untuk membatasi ruang perubahan dan mencegah penimpaan berkas tidak diinginkan.
  \item \textbf{Fitur interaktif}: \textit{interrupt handling} (Ctrl+C) untuk menghentikan respons AI tanpa keluar dari sesi, pencatatan sesi lengkap ke \texttt{.pai\_history}, dan antarmuka terminal responsif dengan dukungan input multiline.
  \item \textbf{Keterulangan eksperimen}: penggunaan pip, virtual environment, dan Makefile memudahkan replikasi lingkungan dan dokumentasi langkah instalasi.
\end{itemize}

\section{Gambar Tinjauan Pustaka}

% Figure 2.1: Konsep arsitektur agentic AI di CLI
\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}[
    node distance=12mm and 16mm,
    box/.style={draw, rounded corners, align=center, minimum width=30mm, minimum height=8mm},
    arrow/.style={-{Stealth}, thick}
  ]
    \node[box] (cli) {Terminal CLI};
    \node[box, right=of cli] (agent) {Agen\\ (Single-Shot)};
    \node[box, right=of agent] (llm) {LLM API\\ (Gemini)};
    \node[box, below=of agent] (workspace) {Workspace Proyek};

    \draw[arrow] (cli) -- node[above]{input} (agent);
    \draw[arrow] (agent) -- node[above]{permintaan} (llm);
    \draw[arrow] (llm) -- node[below]{respons} (agent);
    \draw[arrow] (agent) -- node[right]{\shortstack{READ/WRITE/\\MODIFY/TREE}} (workspace);
    \draw[arrow] (workspace.west) -| (cli.south) node[pos=0.25, below]{hasil};
  \end{tikzpicture}
  \caption{Konsep arsitektur agentic AI di lingkungan CLI dengan inferensi LLM melalui API.}
  \label{fig:arsitektur-agentic-cli}
\end{figure}

Pada Gambar~\ref{fig:arsitektur-agentic-cli} ditunjukkan pemetaan komponen utama (CLI, Agen, LLM, dan komponen workspace) beserta \emph{control/data flow} antar komponen.

% Figure 2.2: Model interaksi stateful/feedback loop
\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}[
    node distance=12mm and 14mm,
    flowstep/.style={draw, rounded corners, align=center, minimum width=32mm, minimum height=8mm},
    arrow/.style={-{Stealth}, thick}
  ]
    \node[flowstep] (input) {Input Pengguna};
    \node[flowstep, right=of input] (plan) {Perencanaan\\ (JSON)};
    \node[flowstep, right=of plan] (exec) {Eksekusi\\ (1--3 subfase)};
    \node[flowstep, below=of plan] (memory) {Konteks / Memori};

    \draw[arrow] (input) -- (plan);
    \draw[arrow] (plan) -- (exec);
    \draw[arrow] (exec) |- node[pos=0.25, right]{hasil} (memory);
    \draw[arrow] (memory) -| node[pos=0.25, below]{umpan balik} (plan);
  \end{tikzpicture}
  \caption{Model interaksi \textit{stateful} dan \textit{feedback loop} pada sesi agen.}
  \label{fig:state-feedback-loop}
\end{figure}

Pada Gambar~\ref{fig:state-feedback-loop} divisualisasikan hubungan antara masukan pengguna, perencanaan aksi, eksekusi alat, dan pembaruan konteks.

% Figure 2.3: Komparasi singkat alat terkait (skema konseptual)
\begin{table}[htbp]
  \centering
  \caption{Ilustrasi komparasi konseptual antara pendekatan ekstensi editor, layanan daring, dan CLI dengan integrasi LLM via API.}
  \label{fig:komparasi-tools}
  \begin{tabular}{@{}p{0.28\textwidth}p{0.30\textwidth}p{0.30\textwidth}@{}}
    \toprule
    & \textbf{Ekstensi Editor} & \textbf{Layanan Daring} \\
    \midrule
    \textbf{Integrasi} & Sangat terintegrasi dengan IDE & Antarmuka web/remote \\
    \textbf{Konteks} & Di editor, tergantung API & Di server; unggah/ sinkron \\
    \textbf{Privasi} & Bergantung vendor & Bergantung vendor \\
    \textbf{Portabilitas} & Terikat IDE & Perlu akses internet \\
    \midrule
    & \multicolumn{2}{c}{\textbf{CLI + LLM via API (Paicode)}} \\
    \midrule
    \textbf{Integrasi} & \multicolumn{2}{c}{Agen berjalan di terminal lokal; perubahan langsung pada workspace} \\
    \textbf{Konteks} & \multicolumn{2}{c}{Konteks lokal; cuplikan dikirim ke LLM via API} \\
    \textbf{Privasi} & \multicolumn{2}{c}{Tergantung kebijakan penyedia API; guardrail lokal} \\
    \textbf{Portabilitas} & \multicolumn{2}{c}{Editor-agnostic; cukup terminal Linux} \\
    \bottomrule
  \end{tabular}
\end{table}

Pada Gambar~\ref{fig:komparasi-tools} ditunjukkan perbedaan fokus dan pertukaran (trade-off) tingkat tinggi antar pendekatan.

% Example citation usage (keep, then replace with real keys):
% Menurut \citet{goodfellow2016deep}, ... atau penelitian terkait \citep{somepaper2020}.
