% Chapter 2 - Tinjauan Pustaka dan Dasar Teori
\chapter{TINJAUAN PUSTAKA DAN DASAR TEORI}
\label{chap:tinjauan}

\section{Tinjauan Pustaka}
\hl{Perkembangan alat bantu pemrograman berbasis AI berkembang pesat dalam beberapa tahun terakhir. Berikut adalah tinjauan terhadap beberapa solusi \textit{state-of-the-art} yang relevan dengan penelitian ini:}

\subsection{AI Coding Assistant Terintegrasi (IDE-based)}
\hl{\citet{copilot2021} menghadirkan GitHub Copilot sebagai asisten pemrograman yang terintegrasi langsung ke dalam lingkungan pengembangan (IDE) seperti VS Code. Copilot unggul dalam memberikan saran \textit{autocomplete} real-time dan fungsi obrolan kontekstual. Namun, pendekatannya sangat bergantung pada antarmuka editor visual dan beroperasi sebagai "pilot pendamping" (copilot) alih-alih agen otonom.}

\subsection{CLI-based AI Chat Tools}
\hl{\citet{gauthier2023aider} mengembangkan Aider untuk membawa kemampuan LLM ke dalam terminal (CLI). Aider memungkinkan pengguna untuk melakukan \textit{pair programming} dengan LLM langsung di terminal dan menerapkan perubahan pada git repository. Pendekatan ini mirip dengan Paicode dalam hal antarmuka berbasis teks. Perbedaannya, Paicode menekankan pada arsitektur \textit{Single-Shot Intelligence} dengan fase perencanaan JSON eksplisit sebelum eksekusi.}

\subsection{Autonomous Software Engineers}
\hl{\citet{opendevin2024} dan \citet{li2024sweagent} masing-masing meluncurkan proyek OpenDevin dan SWE-agent yang bertujuan menciptakan agen yang sepenuhnya otonom, mampu menyelesaikan isu GitHub dari awal hingga akhir tanpa interaksi manusia. Meskipun sangat canggih, pendekatan ini seringkali memerlukan akses sumber daya yang besar (Docker container penuh). Paicode mengambil posisi tengah (\textit{middle-ground}) dengan menyediakan agen \textit{semi-autonomous} yang ringan.}

\subsection{Posisi Paicode}
\hl{Dibandingkan dengan solusi di atas, Paicode menawarkan kebaruan pada kombinasi arsitektur \textit{local-first} yang ringan namun terstruktur:}
\begin{enumerate}
    \item \hl{\textbf{Keamanan Terkendali}: Tidak seperti agen otonom penuh yang sering berjalan di sandboxed container karena risiko tinggi, Paicode dirancang aman untuk berjalan di \textit{host} utama berkat \textit{path security policy} dan \textit{diff-based guardrails}.}
    \item \hl{\textbf{Efisiensi Token}: Dengan arsitektur perencanaan \textit{single-shot}, Paicode mengurangi \textit{round-trip} percakapan yang tidak perlu, berbeda dengan model \textit{chat} standar.}
    \item \hl{\textbf{Transparansi Rencana}: Pengguna dapat melihat rencana aksi (dalam format JSON) sebelum eksekusi masif dilakukan, memberikan kontrol lebih baik daripada model \textit{black-box}.}
\end{enumerate}

\subsection{Perbandingan dengan Penelitian Sebelumnya}

Tabel~\ref{tab:perbandingan-penelitian} merangkum perbedaan antara penelitian-penelitian terdahulu dengan penelitian yang akan dilakukan.

\begin{table}[htbp]
  \centering
  \caption{Perbandingan Penelitian Terdahulu dengan Penelitian yang Dilakukan}
  \label{tab:perbandingan-penelitian}
  \begin{tabular}{@{}p{0.22\textwidth}p{0.35\textwidth}p{0.35\textwidth}@{}}
    \toprule
    \textbf{Aspek} & \textbf{Penelitian Terdahulu} & \textbf{Penelitian Ini (Paicode)} \\
    \midrule
    \textbf{Platform} & IDE-based (Copilot), Web-based (ChatGPT Code Interpreter), Container-based (OpenDevin) & CLI native, berjalan langsung di terminal Linux tanpa container \\
    \midrule
    \textbf{Arsitektur Agen} & Chat-loop iteratif (10-20 API calls) atau fully autonomous & Single-Shot Intelligence (2 phases: planning + execution) \\
    \midrule
    \textbf{Keamanan Lokal} & Sandboxed container (OpenDevin) atau tidak ada kontrol eksplisit (Copilot) & Path security policy + diff-based guardrails (threshold 500 baris, 50\% ratio) \\
    \midrule
    \textbf{Transparansi} & Black-box suggestions (Copilot) atau verbose logs (SWE-agent) & Explicit JSON planning phase dengan user approval \\
    \midrule
    \textbf{Efisiensi} & High token consumption (chat-loop) atau resource-intensive (full containers) & Token-optimized (reduksi round-trip) dan lightweight (native OS) \\
    \midrule
    \textbf{Interaktivitas} & Passive suggestions (Copilot) atau fully autonomous (OpenDevin) & Semi-autonomous dengan interrupt handling (Ctrl+C) \\
    \midrule
    \textbf{Fokus Penelitian} & General-purpose coding atau issue-solving automation & Secure, efficient, transparent automation untuk developer workflows \\
    \bottomrule
  \end{tabular}
\end{table}

\hl{Dari Tabel~\ref{tab:perbandingan-penelitian} terlihat bahwa penelitian ini mengisi \textit{gap} antara asisten pasif (seperti Copilot) dan agen otonom penuh (seperti OpenDevin) dengan menawarkan pendekatan \textit{semi-autonomous} yang efisien, aman, dan transparan. Kebaruan utama terletak pada kombinasi \textbf{Single-Shot Intelligence} untuk efisiensi token, \textbf{path security} untuk keamanan tanpa sandboxing, dan \textbf{explicit planning} untuk transparansiâ€”aspek-aspek yang belum dieksplorasi secara bersamaan dalam penelitian sebelumnya.}


\subsection{Posisi Penelitian}
Kontribusi penelitian ini ditempatkan pada ranah agentic AI untuk pengembangan perangkat lunak dengan karakteristik sebagai berikut:

\begin{itemize}
  \item \textbf{CLI lokal dengan integrasi LLM via API}: agen berjalan di terminal, tindakan langsung tercermin pada \textbf{berkas proyek di workspace}; sementara inferensi dilakukan oleh LLM eksternal sehingga kebijakan data mengikuti penyedia API.
  \item \textbf{Arsitektur Single-Shot Intelligence}: alur kerja efisien yang mengefisienkan penggunaan API dengan 2 fase utama (perencanaan dan eksekusi), menggantikan pendekatan tradisional yang memerlukan 10-20 panggilan API.
  \item \textbf{Manajemen API key tunggal}: sistem manajemen API key yang disederhanakan untuk kemudahan penggunaan.
  \item \textbf{Keamanan berkas}: kebijakan pelarangan akses \textit{path} sensitif dan validasi \textit{path} mencegah \textit{path traversal} dan operasi berisiko pada direktori seperti \texttt{.git}, \texttt{venv}, dan \texttt{.env}.
  \item \textbf{Modifikasi terarah berbasis diff}: perintah \texttt{MODIFY} memanfaatkan sistem \textit{diff}-aware untuk membatasi ruang perubahan dan mencegah penimpaan berkas tidak diinginkan.
  \item \textbf{Fitur interaktif}: \textit{interrupt handling} (Ctrl+C) untuk menghentikan respons AI tanpa keluar dari sesi, pencatatan sesi lengkap ke \texttt{.pai\_history}, dan antarmuka terminal responsif dengan dukungan input multiline.
  \item \textbf{Keterulangan eksperimen}: penggunaan pip, virtual environment, dan Makefile memudahkan replikasi lingkungan dan dokumentasi langkah instalasi.
\end{itemize}

\section{Dasar Teori}
Bagian ini membahas konsep yang menjadi landasan penelitian: \textit{Command Line Interface} (CLI), agen kecerdasan buatan (AI Agent), \textit{Large Language Model} (LLM), arsitektur dan kebijakan data (integrasi LLM melalui API dan implikasi privasi), \textit{Single-Shot Intelligence} untuk agen interaktif, sistem klasifikasi intensi, serta perangkat bantu yang digunakan seperti pip dan virtual environment untuk manajemen dependensi, \texttt{rich} dan \texttt{prompt\_toolkit} untuk antarmuka terminal.

\subsection{Command Line Interface (CLI)}
CLI adalah antarmuka berbasis teks yang memungkinkan pengguna berinteraksi dengan sistem melalui perintah. Kelebihan CLI meliputi otomasi yang mudah, konsumsi sumber daya yang rendah, dan integrasi sederhana dengan alat lain melalui skrip. Dalam konteks pengembangan perangkat lunak, CLI memfasilitasi alur kerja yang ringkas dan dapat direproduksi.

\subsection{AI Agent}
AI Agent (sering disebut \textit{agentic AI} dalam literatur; selanjutnya disingkat "agen AI") dalam penelitian ini dipahami sebagai sistem yang mampu mengobservasi lingkungan (struktur proyek dan isi berkas), merencanakan tindakan (mis. membuat, membaca, memodifikasi berkas), serta mengevaluasi hasil untuk langkah berikutnya. Agen bersifat \textit{stateful} karena mempertahankan konteks percakapan dan hasil eksekusi sebagai memori kerja, sehingga dapat bertindak secara lebih \textit{proactive}.

Pada implementasi Paicode, agen menggunakan arsitektur \textit{Single-Shot Intelligence} yang terdiri dari beberapa komponen: (1) klasifikasi intensi untuk membedakan percakapan dan tugas, (2) \textit{acknowledgment} dinamis untuk konfirmasi pemahaman, (3) fase perencanaan dengan analisis mendalam dan perencanaan komprehensif dalam format JSON, (4) fase eksekusi adaptif yang dapat berjalan dalam 1-3 subfase berdasarkan kompleksitas tugas, dan (5) saran langkah berikutnya. Sistem ini meningkatkan efisiensi dibandingkan pendekatan tradisional yang memerlukan banyak panggilan API berulang.

\subsection{Large Language Model (LLM)}
LLM merupakan model generatif berskala besar yang mampu memahami instruksi dan menghasilkan teks atau kode. Pada penelitian ini digunakan API Gemini sebagai penyedia LLM untuk menghasilkan konten baru (\texttt{WRITE}) dan menerapkan perubahan terarah (\texttt{MODIFY}) berdasarkan deskripsi. Prinsip kehati-hatian diterapkan dengan mekanisme pembatasan perubahan berbasis \textit{diff} sehingga modifikasi tidak berskala besar tanpa kontrol \citep{brown2020gpt3,openai2023gpt4,gemini2023,touvron2023llama,llama2_2023,schick2023toolformer,yao2023react}.

\subsection{Perbedaan LLM dan Agen AI}
\label{subsec:llm-vs-agent}
Pada skripsi ini penting untuk membedakan \textit{Large Language Model} (LLM) dan \textit{Agen AI}:
\begin{itemize}
  \item \textbf{LLM}: model generatif yang menghasilkan keluaran berbasis teks/kode dari masukan. LLM \emph{tidak} menjalankan aksi pada berkas secara langsung; ia hanya memberikan saran/hasil teks.
  \item \textbf{Agen AI}: komponen perangkat lunak yang \emph{mengatur alur kerja} (melakukan perencanaan, memanggil LLM, dan mengeksekusi aksi nyata). Pada konteks ini, agen mengontrol perintah CLI untuk melakukan \textbf{operasi berkas tingkat-aplikasi pada workspace proyek}.
  \item \textbf{Hubungan}: agen memanfaatkan LLM untuk penalaran/generasi, lalu menerjemahkan hasilnya menjadi aksi yang terkontrol. Pengamanan lokal ditegakkan melalui \textit{path security} (keamanan \textit{path}) dan pembatasan perubahan berbasis \textit{diff}.
\end{itemize}

\subsection{Arsitektur dan Kebijakan Data}
Paicode dijalankan pada terminal lokal dan melakukan tindakan langsung pada \textbf{berkas proyek di workspace}. Akan tetapi, untuk kebutuhan inferensi, cuplikan kode atau konteks \textbf{dikirim ke layanan LLM melalui API}. Implikasinya, privasi dan kerahasiaan kode \textbf{bergantung pada kebijakan penyedia API}. Pengamanan di sisi lokal diterapkan melalui kebijakan \textit{path security} (keamanan \textit{path}) serta pembatasan perubahan berbasis \textit{diff} agar operasi berkas lebih terkendali.

\subsection{Manajemen Dependensi dengan pip dan Virtual Environment}
Paicode menggunakan pendekatan manajemen dependensi tradisional dengan pip dan virtual environment Python. Berkas \texttt{requirements.txt} mendeskripsikan dependensi yang diperlukan, sementara Makefile menyediakan otomasi untuk pembuatan virtual environment dan instalasi dependensi. Pendekatan ini memudahkan replikasi lingkungan dan instalasi alat. Pada implementasi Paicode, dependensi utama meliputi \texttt{google-generativeai} (versi $\geq$ 0.5.4), \texttt{rich} (versi $\geq$ 13.7.1), \texttt{Pygments} (versi $\geq$ 2.16.0), dan \texttt{prompt\_toolkit} (versi $\geq$ 3.0.43).

\subsection{Antarmuka Terminal dengan \texttt{rich} dan \texttt{prompt\_toolkit}}
Paket \texttt{rich} dimanfaatkan untuk menyajikan hasil eksekusi secara terstruktur dan mudah dibaca (panel, warna, penyorotan sintaks, tabel, dan spinner status). Penyajian output yang jelas mendukung pengalaman interaktif dan penelusuran hasil tindakan agen. Selain itu, Paicode juga mengintegrasikan \texttt{prompt\_toolkit} (opsional) untuk pengalaman input yang lebih baik dengan dukungan multiline editing dan key bindings. Jika \texttt{prompt\_toolkit} tidak tersedia, sistem akan fallback ke \texttt{rich.prompt.Prompt}.

% Figure 2.1: Konsep arsitektur agentic AI di CLI
\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}[
    node distance=12mm and 16mm,
    box/.style={draw, rounded corners, align=center, minimum width=30mm, minimum height=8mm},
    arrow/.style={-{Stealth}, thick}
  ]
    \node[box] (cli) {Terminal CLI};
    \node[box, right=of cli] (agent) {Agen\\ (Single-Shot)};
    \node[box, right=of agent] (llm) {LLM API\\ (Gemini)};
    \node[box, below=of agent] (workspace) {Workspace Proyek};

    \draw[arrow] (cli) -- node[above]{input} (agent);
    \draw[arrow] (agent) -- node[above]{permintaan} (llm);
    \draw[arrow] (llm) -- node[below]{respons} (agent);
    \draw[arrow] (agent) -- node[right]{\shortstack{READ/WRITE/\\MODIFY/TREE}} (workspace);
    \draw[arrow] (workspace.west) -| (cli.south) node[pos=0.25, below]{hasil};
  \end{tikzpicture}
  \caption{Konsep arsitektur agentic AI di lingkungan CLI dengan inferensi LLM melalui API.}
  \label{fig:arsitektur-agentic-cli}
\end{figure}

Pada Gambar~\ref{fig:arsitektur-agentic-cli} ditunjukkan pemetaan komponen utama (CLI, Agen, LLM, dan komponen workspace) beserta \emph{control/data flow} antar komponen.

% Figure 2.2: Model interaksi stateful/feedback loop
\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}[
    node distance=12mm and 14mm,
    flowstep/.style={draw, rounded corners, align=center, minimum width=32mm, minimum height=8mm},
    arrow/.style={-{Stealth}, thick}
  ]
    \node[flowstep] (input) {Input Pengguna};
    \node[flowstep, right=of input] (plan) {Perencanaan\\ (JSON)};
    \node[flowstep, right=of plan] (exec) {Eksekusi\\ (1--3 subfase)};
    \node[flowstep, below=of plan] (memory) {Konteks / Memori};

    \draw[arrow] (input) -- (plan);
    \draw[arrow] (plan) -- (exec);
    \draw[arrow] (exec) |- node[pos=0.25, right]{hasil} (memory);
    \draw[arrow] (memory) -| node[pos=0.25, below]{umpan balik} (plan);
  \end{tikzpicture}
  \caption{Model interaksi \textit{stateful} dan \textit{feedback loop} pada sesi agen.}
  \label{fig:state-feedback-loop}
\end{figure}

Pada Gambar~\ref{fig:state-feedback-loop} divisualisasikan hubungan antara masukan pengguna, perencanaan aksi, eksekusi alat, dan pembaruan konteks.

% Figure 2.3: Komparasi singkat alat terkait (skema konseptual)
\begin{table}[htbp]
  \centering
  \caption{Ilustrasi komparasi konseptual antara pendekatan ekstensi editor, layanan daring, dan CLI dengan integrasi LLM via API.}
  \label{fig:komparasi-tools}
  \begin{tabular}{@{}p{0.15\textwidth}p{0.26\textwidth}p{0.26\textwidth}p{0.26\textwidth}@{}}
    \toprule
    \textbf{Aspek} & \textbf{Ekstensi Editor} & \textbf{Layanan Daring} & \textbf{Paicode (CLI)} \\
    \midrule
    \textbf{Integrasi} & Sangat terintegrasi dengan IDE & Antarmuka web/remote & Agen di terminal lokal; akses langsung workspace \\
    \midrule
    \textbf{Konteks} & Di editor, tergantung API & Di server; perlu unggah/sinkron & Lokal; cuplikan dikirim ke LLM via API \\
    \midrule
    \textbf{Privasi} & Bergantung vendor & Bergantung vendor & Kebijakan API + guardrail lokal \\
    \midrule
    \textbf{Portabilitas} & Terikat IDE spesifik & Perlu browser & Editor-agnostic; terminal Linux \\
    \bottomrule
  \end{tabular}
\end{table}

Pada Gambar~\ref{fig:komparasi-tools} ditunjukkan perbedaan fokus dan pertukaran (trade-off) tingkat tinggi antar pendekatan.
