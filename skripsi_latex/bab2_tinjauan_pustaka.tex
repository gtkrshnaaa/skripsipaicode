% Chapter 2 - Tinjauan Pustaka
\chapter{Tinjauan Pustaka}
\label{chap:tinjauan}

\section{Teori Dasar}
Bagian ini membahas konsep yang menjadi landasan penelitian: \textit{Command Line Interface} (CLI), agen kecerdasan buatan (AI Agent), \textit{Large Language Model} (LLM), arsitektur dan kebijakan data (integrasi LLM melalui API dan implikasi privasi), \textit{8-step workflow} untuk agen interaktif, sistem klasifikasi intensi, mekanisme \textit{thinking phase} dan \textit{integrity check}, serta perangkat bantu yang digunakan seperti Poetry untuk manajemen dependensi, \texttt{rich} dan \texttt{prompt\_toolkit} untuk antarmuka terminal.

\subsection{Command Line Interface (CLI)}
CLI adalah antarmuka berbasis teks yang memungkinkan pengguna berinteraksi dengan sistem melalui perintah. Kelebihan CLI meliputi otomasi yang mudah, konsumsi sumber daya yang rendah, dan integrasi sederhana dengan alat lain melalui skrip. Dalam konteks pengembangan perangkat lunak, CLI memfasilitasi alur kerja yang ringkas dan dapat direproduksi.

\subsection{AI Agent}
AI Agent (sering disebut \textit{agentic AI} dalam literatur; selanjutnya disingkat "agen AI") dalam penelitian ini dipahami sebagai sistem yang mampu mengobservasi lingkungan (struktur proyek dan isi berkas), merencanakan tindakan (mis. membuat, membaca, memodifikasi berkas), serta mengevaluasi hasil untuk langkah berikutnya. Agen bersifat \textit{stateful} karena mempertahankan konteks percakapan dan hasil eksekusi sebagai memori kerja, sehingga dapat bertindak secara lebih \textit{proactive}.

Pada implementasi Paicode, agen menggunakan arsitektur \textit{8-step workflow} yang mencakup: (1) respon awal agen, (2) penjadwalan tugas berbasis JSON, (3-7) iterasi aksi dengan fase berpikir dan pemeriksaan integritas, serta (8) ringkasan akhir dengan saran langkah berikutnya. Setiap iterasi aksi dilengkapi dengan \textit{thinking phase} untuk penalaran internal sebelum eksekusi, dan \textit{integrity check} pasca-eksekusi yang memberikan skor kualitas 1-10 beserta alasan dan saran perbaikan.

\subsection{Large Language Model (LLM)}
LLM merupakan model generatif berskala besar yang mampu memahami instruksi dan menghasilkan teks atau kode. Pada penelitian ini digunakan API Gemini sebagai penyedia LLM untuk menghasilkan konten baru (\texttt{WRITE}) dan menerapkan perubahan terarah (\texttt{MODIFY}) berdasarkan deskripsi. Prinsip kehati-hatian diterapkan dengan mekanisme pembatasan perubahan berbasis \textit{diff} sehingga modifikasi tidak berskala besar tanpa kontrol \cite{brown2020gpt3,openai2023gpt4,gemini2023,touvron2023llama,llama2_2023,schick2023toolformer,yao2023react}.

\subsection{Perbedaan LLM dan Agen AI}
\label{subsec:llm-vs-agent}
Pada skripsi ini penting untuk membedakan \textit{Large Language Model} (LLM) dan \textit{Agen AI}:
\begin{itemize}
  \item \textbf{LLM}: model generatif yang menghasilkan keluaran berbasis teks/kode dari masukan. LLM \emph{tidak} menjalankan aksi pada berkas secara langsung; ia hanya memberikan saran/hasil teks.
  \item \textbf{Agen AI}: komponen perangkat lunak yang \emph{mengatur alur kerja} (merencanakan, memanggil LLM, dan mengeksekusi aksi nyata). Pada konteks ini, agen mengontrol perintah CLI untuk melakukan \textbf{operasi berkas tingkat-aplikasi pada workspace proyek}.
  \item \textbf{Hubungan}: agen memanfaatkan LLM untuk penalaran/generasi, lalu menerjemahkan hasilnya menjadi aksi yang terkontrol. Pengamanan lokal ditegakkan melalui \textit{path security} (keamanan \textit{path}) dan pembatasan perubahan berbasis \textit{diff}.
\end{itemize}

\subsection{Arsitektur dan Kebijakan Data}
Paicode dijalankan pada terminal lokal dan melakukan tindakan langsung pada \textbf{berkas proyek di workspace}. Akan tetapi, untuk kebutuhan inferensi, cuplikan kode atau konteks \textbf{dikirim ke layanan LLM melalui API}. Implikasinya, privasi dan kerahasiaan kode \textbf{bergantung pada kebijakan penyedia API}. Pengamanan di sisi lokal diterapkan melalui kebijakan \textit{path security} (keamanan \textit{path}) serta pembatasan perubahan berbasis \textit{diff} agar operasi berkas lebih terkendali.

\subsection{Manajemen Dependensi dengan Poetry}
Poetry menyediakan manajemen dependensi dan kemasan proyek Python yang deterministik. Berkas \texttt{pyproject.toml} mendeskripsikan dependensi dan titik masuk CLI (\texttt{pai}). Pendekatan ini memudahkan replikasi lingkungan dan distribusi alat. Pada implementasi Paicode, Poetry juga digunakan untuk mengelola dependensi seperti \texttt{google-generativeai} (versi $\geq$ 0.5.4), \texttt{python-dotenv} (versi $\geq$ 1.0.1), \texttt{rich} (versi $\geq$ 13.7.1), dan \texttt{Pygments} (versi $\geq$ 2.16.0).

\subsection{Antarmuka Terminal dengan \texttt{rich} dan \texttt{prompt\_toolkit}}
Paket \texttt{rich} dimanfaatkan untuk menyajikan hasil eksekusi secara terstruktur dan mudah dibaca (panel, warna, penyorotan sintaks, tabel, dan spinner status). Penyajian output yang jelas mendukung pengalaman interaktif dan penelusuran hasil tindakan agen. Selain itu, Paicode juga mengintegrasikan \texttt{prompt\_toolkit} (opsional) untuk pengalaman input yang lebih baik dengan dukungan multiline editing dan key bindings. Jika \texttt{prompt\_toolkit} tidak tersedia, sistem akan fallback ke \texttt{rich.prompt.Prompt}.

\section{Penelitian Terkait}
Berbagai alat bantu pengembangan perangkat lunak berbasis LLM telah diusulkan dan dikomersialisasi, antara lain asisten kode terintegrasi editor, agen otomatis untuk \textit{refactoring}, serta sistem tanya-jawab dokumentasi. Umumnya solusi tersebut beroperasi sebagai ekstensi editor atau layanan daring, sehingga kuat pada integrasi IDE namun bergantung pada antarmuka tertentu dan memproses konteks di luar mesin pengguna.

Sebaliknya, Paicode menempatkan agen di lingkungan CLI dan beroperasi langsung pada \textbf{berkas proyek di workspace}, sementara inferensi dilakukan oleh LLM eksternal melalui API. Perintah agen disederhanakan ke dalam himpunan tindakan yang eksplisit (\texttt{MKDIR}, \texttt{TOUCH}, \texttt{READ}, \texttt{WRITE}, \texttt{MODIFY}, \texttt{RM}, \texttt{MV}, \texttt{TREE}, \texttt{LIST\_PATH}, \texttt{FINISH}) dengan \textit{policy} \textit{path security}. Penelitian terkait menunjukkan bahwa interaksi \textit{stateful} berbasis rencana aksi meningkatkan kualitas hasil pada tugas-tugas rekayasa perangkat lunak yang iteratif, sementara \textit{guardrail} sederhana (seperti pembatasan \textit{diff}) dapat menekan risiko penimpaan berkas secara tidak disengaja.

\section{Posisi Penelitian}
Kontribusi penelitian ini ditempatkan pada ranah agentic AI untuk pengembangan perangkat lunak dengan karakteristik sebagai berikut:

\begin{itemize}
  \item \textbf{CLI lokal dengan integrasi LLM via API}: agen berjalan di terminal, tindakan langsung tercermin pada \textbf{berkas proyek di workspace}; sementara inferensi dilakukan oleh LLM eksternal sehingga kebijakan data mengikuti penyedia API.
  \item \textbf{Arsitektur 8-step workflow}: alur kerja terstruktur yang mencakup klasifikasi intensi, penjadwalan tugas berbasis JSON, fase berpikir sebelum eksekusi, iterasi aksi, pemeriksaan integritas pasca-eksekusi dengan skor kualitas 1-10, dan ringkasan akhir dengan saran langkah berikutnya.
  \item \textbf{Manajemen multi-API key}: dukungan untuk menyimpan dan mengelola beberapa API key dengan sistem \textit{round-robin load balancing} untuk distribusi beban dan redundansi.
  \item \textbf{Keamanan berkas}: kebijakan pelarangan akses \textit{path} sensitif dan validasi \textit{path} mencegah \textit{path traversal} dan operasi berisiko.
  \item \textbf{Modifikasi terarah dengan threshold}: perintah \texttt{MODIFY} memanfaatkan \textit{diff} untuk membatasi ruang perubahan hingga maksimal 500 baris (dapat dikonfigurasi), mendukung prinsip perubahan minimal dan fokus seperti Professional Programmer.
  \item \textbf{Fitur interaktif}: \textit{interrupt handling} (Ctrl+C) untuk menghentikan respons AI tanpa keluar dari sesi, \textit{auto-continue} untuk melanjutkan saran otomatis, dan pencatatan sesi lengkap ke \texttt{.pai\_history}.
  \item \textbf{Keterulangan eksperimen}: penggunaan Poetry dan Makefile memudahkan replikasi lingkungan dan dokumentasi langkah.
\end{itemize}

\section{Rencana Gambar Tinjauan Pustaka}
Bagian ini mendeskripsikan rencana gambar yang akan disertakan untuk mendukung narasi pada Bab~\ref{chap:tinjauan}. Gambar bersifat ilustratif/konseptual dan akan diganti dengan gambar final sesuai ketersediaan.

% Figure 2.1: Konsep arsitektur agentic AI di CLI
\begin{figure}[htbp]
  \centering
  \fbox{\parbox{0.95\textwidth}{\centering Placeholder gambar: `img/fig2-1-arsitektur-agentic-cli.png`\\
  (Block diagram of components: CLI, Agent, LLM, Workspace; control/data flow)}}
  \caption{Konsep arsitektur agentic AI di lingkungan CLI dengan inferensi LLM melalui API.}
  \label{fig:arsitektur-agentic-cli}
\end{figure}

Pada Gambar~\ref{fig:arsitektur-agentic-cli} ditunjukkan pemetaan komponen utama (CLI, Agen, LLM, dan komponen workspace) beserta \emph{control/data flow} antar komponen.

% Figure 2.2: Model interaksi stateful/feedback loop
\begin{figure}[htbp]
  \centering
  \fbox{\parbox{0.95\textwidth}{\centering Placeholder gambar: `img/fig2-2-state-loop.png`\\
  (Skema loop: input pengguna → rencana → eksekusi alat → hasil → memori)}}
  \caption{Model interaksi \textit{stateful} dan \textit{feedback loop} pada sesi agen.}
  \label{fig:state-feedback-loop}
\end{figure}

Pada Gambar~\ref{fig:state-feedback-loop} divisualisasikan hubungan antara masukan pengguna, rencana aksi, eksekusi alat, dan pembaruan konteks.

% Figure 2.3: Komparasi singkat alat terkait (skema konseptual)
\begin{figure}[htbp]
  \centering
  \fbox{\parbox{0.95\textwidth}{\centering Placeholder gambar: `img/fig2-3-komparasi-tools.png`\\
  (Tabel/diagram perbandingan: editor extension vs layanan cloud vs CLI + LLM via API)}}
  \caption{Ilustrasi komparasi konseptual antara pendekatan ekstensi editor, layanan daring, dan CLI dengan integrasi LLM via API.}
  \label{fig:komparasi-tools}
\end{figure}

Pada Gambar~\ref{fig:komparasi-tools} ditunjukkan perbedaan fokus dan pertukaran (trade-off) tingkat tinggi antar pendekatan.

% Example citation usage (keep, then replace with real keys):
% Menurut \citet{goodfellow2016deep}, ... atau penelitian terkait \citep{somepaper2020}.
